1、锚定 例：^cat不要理解为以cat开头的行，正确理解应为c作为一行第一个字符，紧接着a,紧接着t的文本
^cat$   文字意义：匹配的条件是，行开头，然后是字母c*a*t，然后是行末尾
	应用意义：只包含cat的行――没有多余的单词，空白字符……只有‘cat’.

^$	文字意义：匹配的条件是，行开头，然后是行末尾
	应用意义：空行（没有任何字符，包括空白字符）

^	文字意义：匹配条件是行开头
	应用意义：无意义！因为每一行都有开头，所以每一行都能匹配――空行也不例外

排除字符组：
用[^…]取代[…],这个字符组就会匹配任何未列出的字符。例如：[^1-6]；匹配除了1到6以外的任何字符。
这个字符组中的开头^，表示排除，所以这里列出的不是希望匹配的字符，而是不希望匹配的字符。

场景：我们需要在一堆引文单词中搜索出一些特殊的单词。在这些单词中，字母q后面的字母不是u,在桌面新建一个test.txt的文档，文档中插入Iraqi
Iraqian
quation
qasida
Iraq
Qantas
tasq
，打开CMD命令输入findstr "[Qq][^u]" C:\Users\YF\Desktop\test.txt 命令即可查找到匹配的文本信息


用点号来匹配任意字符：
例如：我们要搜索03/19/76 或者03.19.76，不怕麻烦的话用一个明确容许'/'、'-'、'.'的字符来构建正则表达式。例如：03[-./]19[-./]76。也可以简单的尝试03.19.76


多选结构：
匹配任意子表达式：
| 是一个非常简捷的元字符，他的意思是“或”。假如 Bob和Robert是两个表达式，但Bob|Robert就能同时匹配其中任意一个的正则表达式。这样的组合中，子表达式称为“多选分支”

忽略大小写：
egrep的命令行参数“-i”表示进行忽略大小写的匹配，把-i写在正则表达式之前：
 % egrep -i '^(From|Subject|Date):' mailbox

单词分界符：
如果你的egrep支持元字符序列 如：[\<]和[\>] 就可以用他们来进行匹配单词分界的位置
如匹配cat这个单词，如果愿意，正则表达式可以用 \<cat 和 cat\> 来匹配以cat开头和结束的单词
注意：单纯的<和>本身不是元字符――只有当他们与斜线结合起来的时候，整个序列才具有特殊的意义。

至今为止所做笔记的元字符小结
元字符			名称			匹配对象
.			点号			单个任意字符

[…]			字符组			列出任意个字符

[^…]			排除型字符组		未列出的任意字符

^			脱字符			行的起始位置

$			美元符			行的结束位置

\<			反斜线-小于		单词的起始位置

\>			反斜线-大于		单词的结束位置

|			竖线			匹配分隔两边的任意一个表达式

(…)			括号			限制竖线的作用范围



可选项元素：
现在举个例子：来看color和colour的匹配，他们的区别在于，后面的单词比前面的多一个u，我们可以用colou?r来解决这个问题。元字符？（问号）代表可选项。把它加载一个字符的后面，就表示此处允许出现这个字符。不过它的出现并非匹配成功的必要条件。
u?这个元字符与我们之前看到的元字符都不相同，它只作用于之前紧邻的元素。因此，colou?r的意思是：c，然后是o,然后是l，然后是o,然后是u?，最后是r。
u?是必然能够匹配成功的，有时它会匹配一个u，其他时候则不匹配任何字符串。关键在于，无论u是否出现，匹配都会成功。但这并不等于，任何包含？的正则表达式都永远能匹配成功。例如：colo和u?都能在‘semicolon’中匹配成功（前者匹配单词中的colo，厚泽什么字符都没有匹配。）可最后的r无法匹配，因此，最终colou?r无法匹配semicolon。
来看另外一个例子：我们需要匹配表示7月4日（July fourth）的文本，其中月份可能写作July或者是Jul，而日期可能写作fourth、4th或者是4,。显然我们可以用(July|Jul)*(fourth|4th|4)这个正则表达式来查找文本。但也可以通过其他的办法来解决这个问题。
首先我们把（July|Jul）缩写为（July?）。你明白这种等价变化吗？删除|后，就没必要保留括号了，当然也可以留着。但不保留括号更简洁一些。于是我们得到以下正则表达式:July?*(fourth|4th|4)。
现在来看第二部分，我们可以把 4th|4简化成4(th)?。我们看到了什么？现在？作用的元素是整个括号了。括号内的表达式可以任意复杂，但是“从括号外面来看”它们是个整体，界定？的作用对象是括号的主要用途之一。
现在修改我们的表达式，July?*(fourth|4(th)?)
